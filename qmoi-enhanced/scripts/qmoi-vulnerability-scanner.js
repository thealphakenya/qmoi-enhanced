#!/usr/bin/env node

/**
 * QMOI Vulnerability Scanner & Fixer
 * Comprehensive security vulnerability detection and remediation
 * Supports npm audit, Snyk, Semgrep, and custom security checks
 */

import { promises as fs } from "fs";
import path from "path";
import crypto from "crypto";
import { exec } from "child_process";
import { promisify } from "util";
import QMOINotificationSystem from "./qmoi-notification-system.js";

const execAsync = promisify(exec);

class QMOIVulnerabilityScanner {
  constructor() {
    this.notificationSystem = new QMOINotificationSystem();
    this.scanResults = [];
    this.fixHistory = [];
    this.securityTools = {
      npm: { enabled: true, command: "npm audit" },
      snyk: { enabled: false, command: "npx snyk test" },
      semgrep: { enabled: false, command: "npx semgrep ci" },
      custom: { enabled: true, patterns: [] },
    };
  }

  async initialize() {
    console.log("üîí Initializing QMOI Vulnerability Scanner...");
    await this.notificationSystem.initialize();

    // Check for security tools
    await this.checkSecurityTools();

    console.log("‚úÖ QMOI Vulnerability Scanner initialized");
  }

  async checkSecurityTools() {
    console.log("üîç Checking available security tools...");

    // Check npm
    try {
      await execAsync("npm --version");
      this.securityTools.npm.enabled = true;
      console.log("‚úÖ npm available");
    } catch (error) {
      this.securityTools.npm.enabled = false;
      console.log("‚ùå npm not available");
    }

    // Check Snyk
    try {
      await execAsync("npx snyk --version");
      this.securityTools.snyk.enabled = true;
      console.log("‚úÖ Snyk available");
    } catch (error) {
      console.log("‚ö†Ô∏è Snyk not available (install with: npm install -g snyk)");
    }

    // Check Semgrep
    try {
      await execAsync("npx semgrep --version");
      this.securityTools.semgrep.enabled = true;
      console.log("‚úÖ Semgrep available");
    } catch (error) {
      console.log(
        "‚ö†Ô∏è Semgrep not available (install with: npm install -g @semgrep/semgrep)",
      );
    }
  }

  async scanAll() {
    console.log("üîç Starting comprehensive vulnerability scan...");

    const scanReport = {
      timestamp: new Date().toISOString(),
      scans: [],
      summary: {
        totalVulnerabilities: 0,
        criticalVulnerabilities: 0,
        highVulnerabilities: 0,
        mediumVulnerabilities: 0,
        lowVulnerabilities: 0,
        fixesApplied: 0,
      },
    };

    try {
      // NPM Audit Scan
      if (this.securityTools.npm.enabled) {
        const npmResults = await this.runNpmAudit();
        scanReport.scans.push({ tool: "npm", ...npmResults });
      }

      // Snyk Scan
      if (this.securityTools.snyk.enabled) {
        const snykResults = await this.runSnykScan();
        scanReport.scans.push({ tool: "snyk", ...snykResults });
      }

      // Semgrep Scan
      if (this.securityTools.semgrep.enabled) {
        const semgrepResults = await this.runSemgrepScan();
        scanReport.scans.push({ tool: "semgrep", ...semgrepResults });
      }

      // Custom Security Checks
      const customResults = await this.runCustomSecurityChecks();
      scanReport.scans.push({ tool: "custom", ...customResults });

      // Update summary
      scanReport.summary = this.calculateSummary(scanReport.scans);

      // Auto-fix vulnerabilities
      const fixResults = await this.autoFixVulnerabilities(scanReport.scans);
      scanReport.fixes = fixResults;
      scanReport.summary.fixesApplied = fixResults.filter(
        (f) => f.success,
      ).length;

      // Save report
      await fs.writeFile(
        "logs/qmoi-vulnerability-scan-report.json",
        JSON.stringify(scanReport, null, 2),
      );

      // Send notification
      await this.sendVulnerabilityNotification(scanReport);

      console.log(
        `‚úÖ Vulnerability scan completed: ${scanReport.summary.totalVulnerabilities} vulnerabilities found, ${scanReport.summary.fixesApplied} fixed`,
      );
      return scanReport;
    } catch (error) {
      console.error("‚ùå Vulnerability scan failed:", error.message);
      await this.sendErrorNotification(
        "Vulnerability Scan Failed",
        error.message,
      );
      throw error;
    }
  }

  async runNpmAudit() {
    console.log("üîç Running npm audit...");

    try {
      const { stdout, stderr } = await execAsync("npm audit --json");
      const auditData = JSON.parse(stdout);

      const vulnerabilities = [];
      if (auditData.vulnerabilities) {
        for (const [packageName, vuln] of Object.entries(
          auditData.vulnerabilities,
        )) {
          vulnerabilities.push({
            package: packageName,
            severity: vuln.severity,
            title: vuln.title,
            description: vuln.description,
            recommendation: vuln.recommendation,
            via: vuln.via,
          });
        }
      }

      return {
        success: true,
        vulnerabilities,
        summary: auditData.metadata || {},
      };
    } catch (error) {
      // npm audit might fail if vulnerabilities are found
      try {
        const errorOutput = JSON.parse(error.stdout || "{}");
        return {
          success: false,
          vulnerabilities: errorOutput.vulnerabilities
            ? Object.values(errorOutput.vulnerabilities)
            : [],
          error: error.message,
          summary: errorOutput.metadata || {},
        };
      } catch (parseError) {
        return {
          success: false,
          vulnerabilities: [],
          error: error.message,
        };
      }
    }
  }

  async runSnykScan() {
    console.log("üîç Running Snyk scan...");

    try {
      const { stdout } = await execAsync("npx snyk test --json");
      const snykData = JSON.parse(stdout);

      const vulnerabilities = snykData.vulnerabilities || [];

      return {
        success: true,
        vulnerabilities: vulnerabilities.map((vuln) => ({
          package: vuln.packageName,
          severity: vuln.severity,
          title: vuln.title,
          description: vuln.description,
          recommendation: vuln.recommendation,
          cve: vuln.identifiers?.CVE,
        })),
        summary: {
          total: vulnerabilities.length,
          critical: vulnerabilities.filter((v) => v.severity === "critical")
            .length,
          high: vulnerabilities.filter((v) => v.severity === "high").length,
          medium: vulnerabilities.filter((v) => v.severity === "medium").length,
          low: vulnerabilities.filter((v) => v.severity === "low").length,
        },
      };
    } catch (error) {
      return {
        success: false,
        vulnerabilities: [],
        error: error.message,
      };
    }
  }

  async runSemgrepScan() {
    console.log("üîç Running Semgrep scan...");

    try {
      const { stdout } = await execAsync("npx semgrep ci --json");
      const semgrepData = JSON.parse(stdout);

      const vulnerabilities = semgrepData.results || [];

      return {
        success: true,
        vulnerabilities: vulnerabilities.map((result) => ({
          file: result.path,
          line: result.start.line,
          severity: result.extra.severity,
          title: result.extra.title,
          description: result.extra.message,
          rule: result.check_id,
        })),
        summary: {
          total: vulnerabilities.length,
          critical: vulnerabilities.filter((v) => v.severity === "ERROR")
            .length,
          high: vulnerabilities.filter((v) => v.severity === "WARNING").length,
          medium: vulnerabilities.filter((v) => v.severity === "INFO").length,
        },
      };
    } catch (error) {
      return {
        success: false,
        vulnerabilities: [],
        error: error.message,
      };
    }
  }

  async runCustomSecurityChecks() {
    console.log("üîç Running custom security checks...");

    const vulnerabilities = [];

    try {
      // Check for hardcoded secrets
      const secretPatterns = [
        /password\s*[:=]\s*['"][^'"]+['"]/gi,
        /api_key\s*[:=]\s*['"][^'"]+['"]/gi,
        /secret\s*[:=]\s*['"][^'"]+['"]/gi,
        /token\s*[:=]\s*['"][^'"]+['"]/gi,
      ];

      const files = await this.findFiles(
        ".js",
        ".ts",
        ".json",
        ".env",
        ".yml",
        ".yaml",
      );

      for (const file of files) {
        try {
          const content = await fs.readFile(file, "utf8");

          for (const pattern of secretPatterns) {
            const matches = content.match(pattern);
            if (matches) {
              vulnerabilities.push({
                file,
                severity: "high",
                title: "Hardcoded Secret Detected",
                description: `Potential hardcoded secret found in ${file}`,
                recommendation:
                  "Move secrets to environment variables or secure storage",
                matches: matches.length,
              });
            }
          }
        } catch (error) {
          // Skip files that can't be read
        }
      }

      // Check for outdated dependencies
      try {
        const { stdout } = await execAsync("npm outdated --json");
        const outdated = JSON.parse(stdout);

        for (const [packageName, info] of Object.entries(outdated)) {
          vulnerabilities.push({
            package: packageName,
            severity: "medium",
            title: "Outdated Dependency",
            description: `${packageName} is outdated (current: ${info.current}, latest: ${info.latest})`,
            recommendation: `Update ${packageName} to version ${info.latest}`,
            current: info.current,
            latest: info.latest,
          });
        }
      } catch (error) {
        // No outdated packages or error
      }

      return {
        success: true,
        vulnerabilities,
        summary: {
          total: vulnerabilities.length,
          high: vulnerabilities.filter((v) => v.severity === "high").length,
          medium: vulnerabilities.filter((v) => v.severity === "medium").length,
          low: vulnerabilities.filter((v) => v.severity === "low").length,
        },
      };
    } catch (error) {
      return {
        success: false,
        vulnerabilities: [],
        error: error.message,
      };
    }
  }

  async autoFixVulnerabilities(scans) {
    console.log("üîß Attempting to auto-fix vulnerabilities...");

    const fixes = [];

    for (const scan of scans) {
      if (scan.tool === "npm" && scan.vulnerabilities.length > 0) {
        try {
          // Try npm audit fix
          await execAsync("npm audit fix");
          fixes.push({
            tool: "npm",
            action: "audit_fix",
            success: true,
            message: "Applied npm audit fixes",
          });
        } catch (error) {
          fixes.push({
            tool: "npm",
            action: "audit_fix",
            success: false,
            error: error.message,
          });
        }
      }

      if (scan.tool === "custom") {
        // Fix hardcoded secrets
        const secretVulns = scan.vulnerabilities.filter(
          (v) => v.title === "Hardcoded Secret Detected",
        );
        for (const vuln of secretVulns) {
          try {
            await this.fixHardcodedSecret(vuln.file);
            fixes.push({
              tool: "custom",
              action: "fix_hardcoded_secret",
              file: vuln.file,
              success: true,
              message: "Replaced hardcoded secret with environment variable",
            });
          } catch (error) {
            fixes.push({
              tool: "custom",
              action: "fix_hardcoded_secret",
              file: vuln.file,
              success: false,
              error: error.message,
            });
          }
        }

        // Fix outdated dependencies
        const outdatedVulns = scan.vulnerabilities.filter(
          (v) => v.title === "Outdated Dependency",
        );
        for (const vuln of outdatedVulns) {
          try {
            await execAsync(`npm install ${vuln.package}@${vuln.latest}`);
            fixes.push({
              tool: "custom",
              action: "update_dependency",
              package: vuln.package,
              success: true,
              message: `Updated ${vuln.package} to ${vuln.latest}`,
            });
          } catch (error) {
            fixes.push({
              tool: "custom",
              action: "update_dependency",
              package: vuln.package,
              success: false,
              error: error.message,
            });
          }
        }
      }
    }

    return fixes;
  }

  async fixHardcodedSecret(filePath) {
    const content = await fs.readFile(filePath, "utf8");

    // Replace hardcoded secrets with environment variables
    let fixedContent = content
      .replace(
        /password\s*[:=]\s*['"][^'"]+['"]/gi,
        "password: process.env.PASSWORD",
      )
      .replace(
        /api_key\s*[:=]\s*['"][^'"]+['"]/gi,
        "api_key: process.env.API_KEY",
      )
      .replace(/secret\s*[:=]\s*['"][^'"]+['"]/gi, "secret: process.env.SECRET")
      .replace(/token\s*[:=]\s*['"][^'"]+['"]/gi, "token: process.env.TOKEN");

    // Create backup
    const backupPath = `${filePath}.backup.${Date.now()}`;
    await fs.writeFile(backupPath, content);

    // Write fixed content
    await fs.writeFile(filePath, fixedContent);
  }

  async findFiles(...extensions) {
    const files = [];

    async function scanDirectory(dir) {
      try {
        const items = await fs.readdir(dir, { withFileTypes: true });

        for (const item of items) {
          const fullPath = path.join(dir, item.name);

          if (
            item.isDirectory() &&
            !item.name.startsWith(".") &&
            item.name !== "node_modules"
          ) {
            await scanDirectory(fullPath);
          } else if (
            item.isFile() &&
            extensions.some((ext) => item.name.endsWith(ext))
          ) {
            files.push(fullPath);
          }
        }
      } catch (error) {
        // Skip directories that can't be read
      }
    }

    await scanDirectory(".");
    return files;
  }

  calculateSummary(scans) {
    const summary = {
      totalVulnerabilities: 0,
      criticalVulnerabilities: 0,
      highVulnerabilities: 0,
      mediumVulnerabilities: 0,
      lowVulnerabilities: 0,
    };

    for (const scan of scans) {
      if (scan.summary) {
        summary.totalVulnerabilities +=
          scan.summary.total || scan.vulnerabilities.length;
        summary.criticalVulnerabilities += scan.summary.critical || 0;
        summary.highVulnerabilities += scan.summary.high || 0;
        summary.mediumVulnerabilities += scan.summary.medium || 0;
        summary.lowVulnerabilities += scan.summary.low || 0;
      }
    }

    return summary;
  }

  async sendVulnerabilityNotification(scanReport) {
    const message = `
üîí QMOI Vulnerability Scan Report

üìä Summary:
‚Ä¢ Total Vulnerabilities: ${scanReport.summary.totalVulnerabilities}
‚Ä¢ Critical: ${scanReport.summary.criticalVulnerabilities}
‚Ä¢ High: ${scanReport.summary.highVulnerabilities}
‚Ä¢ Medium: ${scanReport.summary.mediumVulnerabilities}
‚Ä¢ Low: ${scanReport.summary.lowVulnerabilities}
‚Ä¢ Fixes Applied: ${scanReport.summary.fixesApplied}

üîß Tools Used:
${scanReport.scans.map((scan) => `‚Ä¢ ${scan.tool}: ${scan.success ? "‚úÖ" : "‚ùå"} (${scan.vulnerabilities.length} issues)`).join("\n")}

${
  scanReport.summary.criticalVulnerabilities > 0
    ? `
üö® CRITICAL VULNERABILITIES FOUND!
Please review and fix immediately.
`
    : ""
}

üìÅ Report saved to: logs/qmoi-vulnerability-scan-report.json
    `.trim();

    const severity =
      scanReport.summary.criticalVulnerabilities > 0
        ? "error"
        : scanReport.summary.highVulnerabilities > 0
          ? "warning"
          : "success";

    await this.notificationSystem.sendNotification(
      severity,
      "QMOI Vulnerability Scan Complete",
      message,
      {
        details: {
          summary: scanReport.summary,
          timestamp: scanReport.timestamp,
        },
      },
    );
  }

  async sendErrorNotification(title, error) {
    await this.notificationSystem.sendNotification(
      "error",
      title,
      `QMOI Vulnerability Scanner encountered an error: ${error}`,
      {
        details: {
          error,
          timestamp: new Date().toISOString(),
        },
      },
    );
  }
}

// CLI interface
const isMainModule =
  process.argv[1] && process.argv[1].endsWith("qmoi-vulnerability-scanner.js");
if (isMainModule) {
  const scanner = new QMOIVulnerabilityScanner();
  const args = process.argv.slice(2);

  async function main() {
    await scanner.initialize();

    if (args.includes("--scan")) {
      console.log("üîç Running vulnerability scan...");
      const report = await scanner.scanAll();
      console.log("Scan report:", JSON.stringify(report, null, 2));
    } else if (args.includes("--install-tools")) {
      console.log("üîß Installing security tools...");
      try {
        await execAsync("npm install -g snyk @semgrep/semgrep");
        console.log("‚úÖ Security tools installed");
      } catch (error) {
        console.error("‚ùå Failed to install tools:", error.message);
      }
    } else {
      console.log(`
QMOI Vulnerability Scanner

Usage:
  node qmoi-vulnerability-scanner.js --scan              # Run comprehensive vulnerability scan
  node qmoi-vulnerability-scanner.js --install-tools     # Install security tools

Features:
  ‚Ä¢ NPM audit integration
  ‚Ä¢ Snyk security scanning
  ‚Ä¢ Semgrep code analysis
  ‚Ä¢ Custom security checks (hardcoded secrets, outdated deps)
  ‚Ä¢ Automatic vulnerability fixing
  ‚Ä¢ Comprehensive reporting
  ‚Ä¢ Integration with QMOI notification system

Examples:
  node qmoi-vulnerability-scanner.js --scan
  node qmoi-vulnerability-scanner.js --install-tools
`);
    }
  }

  main().catch(console.error);
}

export default QMOIVulnerabilityScanner;
