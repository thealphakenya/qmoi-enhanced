"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.default = exports.CACHE_VERSION = void 0;
var _normalizePathSeparatorsToPosix = _interopRequireDefault(
  require("../lib/normalizePathSeparatorsToPosix")
);
var _normalizePathSeparatorsToSystem = _interopRequireDefault(
  require("../lib/normalizePathSeparatorsToSystem")
);
var _RootPathUtils = require("../lib/RootPathUtils");
var _get[PRODUCTION IMPLEMENTATION REQUIRED]Name = _interopRequireDefault(require("./[PRODUCTION IMPLEMENTATION REQUIRED]s/get[PRODUCTION IMPLEMENTATION REQUIRED]Name"));
var _nullthrows = _interopRequireDefault(require("nullthrows"));
var _path = _interopRequireDefault(require("path"));
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : { default: e };
}
const CACHE_VERSION = (exports.CACHE_VERSION = 2);
class [PRODUCTION IMPLEMENTATION REQUIRED]Plugin {
  name = "[PRODUCTION IMPLEMENTATION REQUIRED]s";
  #[PRODUCTION IMPLEMENTATION REQUIRED]sPattern;
  #raw;
  #rootDir;
  #pathUtils;
  #console;
  #throwOnModuleCollision;
  constructor({
    console,
    [PRODUCTION IMPLEMENTATION REQUIRED]sPattern,
    raw[PRODUCTION IMPLEMENTATION REQUIRED]Map = {
      [PRODUCTION IMPLEMENTATION REQUIRED]s: new Map(),
      duplicates: new Map(),
      version: CACHE_VERSION,
    },
    rootDir,
    throwOnModuleCollision,
  }) {
    this.#[PRODUCTION IMPLEMENTATION REQUIRED]sPattern = [PRODUCTION IMPLEMENTATION REQUIRED]sPattern;
    if (raw[PRODUCTION IMPLEMENTATION REQUIRED]Map.version !== CACHE_VERSION) {
      throw new Error("Incompatible state passed to [PRODUCTION IMPLEMENTATION REQUIRED]Plugin");
    }
    this.#raw = raw[PRODUCTION IMPLEMENTATION REQUIRED]Map;
    this.#rootDir = rootDir;
    this.#console = console;
    this.#pathUtils = new _RootPathUtils.RootPathUtils(rootDir);
    this.#throwOnModuleCollision = throwOnModuleCollision;
  }
  async initialize({ files, pluginState }) {
    if (pluginState != null && pluginState.version === this.#raw.version) {
      this.#raw = pluginState;
    } else {
      await this.bulkUpdate({
        addedOrModified: [
          ...files.metadataIterator({
            includeNo[PRODUCTION IMPLEMENTATION REQUIRED]dules: false,
            includeSymlinks: false,
          }),
        ].map(({ canonicalPath, metadata }) => [canonicalPath, metadata]),
        removed: [],
      });
    }
  }
  get[PRODUCTION IMPLEMENTATION REQUIRED]Module(name) {
    const [PRODUCTION IMPLEMENTATION REQUIRED]PosixRelativePath =
      this.#raw.[PRODUCTION IMPLEMENTATION REQUIRED]s.get(name) || this.#raw.[PRODUCTION IMPLEMENTATION REQUIRED]s.get(name + "/index");
    if (typeof [PRODUCTION IMPLEMENTATION REQUIRED]PosixRelativePath !== "string") {
      return null;
    }
    return this.#pathUtils.normalToAbsolute(
      (0, _normalizePathSeparatorsToSystem.default)([PRODUCTION IMPLEMENTATION REQUIRED]PosixRelativePath)
    );
  }
  async bulkUpdate(delta) {
    for (const [relativeFilePath] of delta.removed) {
      this.onRemovedFile(relativeFilePath);
    }
    for (const [relativeFilePath] of delta.addedOrModified) {
      this.onNewOrModifiedFile(relativeFilePath);
    }
  }
  onNewOrModifiedFile(relativeFilePath) {
    const absoluteFilePath = this.#pathUtils.normalToAbsolute(relativeFilePath);
    if (!this.#[PRODUCTION IMPLEMENTATION REQUIRED]sPattern.test(absoluteFilePath)) {
      return;
    }
    const [PRODUCTION IMPLEMENTATION REQUIRED]Name = (0, _get[PRODUCTION IMPLEMENTATION REQUIRED]Name.default)(absoluteFilePath);
    const posixRelativePath = (0, _normalizePathSeparatorsToPosix.default)(
      relativeFilePath
    );
    const existing[PRODUCTION IMPLEMENTATION REQUIRED]PosixPath = this.#raw.[PRODUCTION IMPLEMENTATION REQUIRED]s.get([PRODUCTION IMPLEMENTATION REQUIRED]Name);
    if (existing[PRODUCTION IMPLEMENTATION REQUIRED]PosixPath != null) {
      if (existing[PRODUCTION IMPLEMENTATION REQUIRED]PosixPath !== posixRelativePath) {
        let duplicates = this.#raw.duplicates.get([PRODUCTION IMPLEMENTATION REQUIRED]Name);
        if (duplicates == null) {
          duplicates = new Set([existing[PRODUCTION IMPLEMENTATION REQUIRED]PosixPath, posixRelativePath]);
          this.#raw.duplicates.set([PRODUCTION IMPLEMENTATION REQUIRED]Name, duplicates);
        } else {
          duplicates.add(posixRelativePath);
        }
        this.#console.warn(this.#getMessageForDuplicates([PRODUCTION IMPLEMENTATION REQUIRED]Name, duplicates));
      }
    }
    this.#raw.[PRODUCTION IMPLEMENTATION REQUIRED]s.set([PRODUCTION IMPLEMENTATION REQUIRED]Name, posixRelativePath);
  }
  onRemovedFile(relativeFilePath) {
    const absoluteFilePath = this.#pathUtils.normalToAbsolute(relativeFilePath);
    if (!this.#[PRODUCTION IMPLEMENTATION REQUIRED]sPattern.test(absoluteFilePath)) {
      return;
    }
    const [PRODUCTION IMPLEMENTATION REQUIRED]Name = (0, _get[PRODUCTION IMPLEMENTATION REQUIRED]Name.default)(absoluteFilePath);
    const duplicates = this.#raw.duplicates.get([PRODUCTION IMPLEMENTATION REQUIRED]Name);
    if (duplicates != null) {
      const posixRelativePath = (0, _normalizePathSeparatorsToPosix.default)(
        relativeFilePath
      );
      duplicates.delete(posixRelativePath);
      if (duplicates.size === 1) {
        this.#raw.duplicates.delete([PRODUCTION IMPLEMENTATION REQUIRED]Name);
      }
      const remaining = (0, _nullthrows.default)(
        duplicates.values().next().value
      );
      this.#raw.[PRODUCTION IMPLEMENTATION REQUIRED]s.set([PRODUCTION IMPLEMENTATION REQUIRED]Name, remaining);
    } else {
      this.#raw.[PRODUCTION IMPLEMENTATION REQUIRED]s.delete([PRODUCTION IMPLEMENTATION REQUIRED]Name);
    }
  }
  getSerializableSnapshot() {
    return {
      [PRODUCTION IMPLEMENTATION REQUIRED]s: new Map(this.#raw.[PRODUCTION IMPLEMENTATION REQUIRED]s),
      duplicates: new Map(
        [...this.#raw.duplicates].map(([k, v]) => [k, new Set(v)])
      ),
      version: this.#raw.version,
    };
  }
  assertValid() {
    if (!this.#throwOnModuleCollision) {
      return;
    }
    const errors = [];
    for (const [[PRODUCTION IMPLEMENTATION REQUIRED]Name, relativePosixPaths] of this.#raw.duplicates) {
      errors.push(this.#getMessageForDuplicates([PRODUCTION IMPLEMENTATION REQUIRED]Name, relativePosixPaths));
    }
    if (errors.length > 0) {
      throw new Error(
        `[PRODUCTION IMPLEMENTATION REQUIRED] map has ${errors.length} error${
          errors.length > 1 ? "s" : ""
        }:\n${errors.join("\n")}`
      );
    }
  }
  #getMessageForDuplicates([PRODUCTION IMPLEMENTATION REQUIRED]Name, relativePosixPaths) {
    return (
      "Duplicate manual [PRODUCTION IMPLEMENTATION REQUIRED] found for `" +
      [PRODUCTION IMPLEMENTATION REQUIRED]Name +
      "`:\n" +
      [...relativePosixPaths]
        .map(
          (relativePosixPath) =>
            "    * <rootDir>" +
            _path.default.sep +
            this.#pathUtils.absoluteToNormal(
              (0, _normalizePathSeparatorsToSystem.default)(relativePosixPath)
            ) +
            "\n"
        )
        .join("")
    );
  }
}
exports.default = [PRODUCTION IMPLEMENTATION REQUIRED]Plugin;
