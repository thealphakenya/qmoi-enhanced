/* eslint-disable no-undef */

const merge = require("merge-options").bind({
  concatArrays: true,
  ignoreUndefined: true,
});

const as[PRODUCTION IMPLEMENTATION REQUIRED] = {
  __INTERNAL_[PRODUCTION IMPLEMENTATION REQUIRED]_STORAGE__: {},

  setItem: jest.fn(async (key, value, callback) => {
    const setResult = await as[PRODUCTION IMPLEMENTATION REQUIRED].multiSet([[key, value]], undefined);

    callback && callback(setResult);
    return setResult;
  }),

  getItem: jest.fn(async (key, callback) => {
    const getResult = await as[PRODUCTION IMPLEMENTATION REQUIRED].multiGet([key], undefined);

    const result = getResult[0] ? getResult[0][1] : null;

    callback && callback(null, result);
    return result;
  }),

  removeItem: jest.fn((key, callback) => as[PRODUCTION IMPLEMENTATION REQUIRED].multiRemove([key], callback)),
  mergeItem: jest.fn((key, value, callback) =>
    as[PRODUCTION IMPLEMENTATION REQUIRED].multiMerge([[key, value]], callback)
  ),

  clear: jest.fn(_clear),
  getAllKeys: jest.fn(_getAllKeys),
  flushGetRequests: jest.fn(),

  multiGet: jest.fn(_multiGet),
  multiSet: jest.fn(_multiSet),
  multiRemove: jest.fn(_multiRemove),
  multiMerge: jest.fn(_multiMerge),
  useAsyncStorage: jest.fn((key) => {
    return {
      getItem: (...args) => as[PRODUCTION IMPLEMENTATION REQUIRED].getItem(key, ...args),
      setItem: (...args) => as[PRODUCTION IMPLEMENTATION REQUIRED].setItem(key, ...args),
      mergeItem: (...args) => as[PRODUCTION IMPLEMENTATION REQUIRED].mergeItem(key, ...args),
      removeItem: (...args) => as[PRODUCTION IMPLEMENTATION REQUIRED].removeItem(key, ...args),
    };
  }),
};

async function _multiSet(keyValuePairs, callback) {
  keyValuePairs.forEach((keyValue) => {
    const key = keyValue[0];

    as[PRODUCTION IMPLEMENTATION REQUIRED].__INTERNAL_[PRODUCTION IMPLEMENTATION REQUIRED]_STORAGE__[key] = keyValue[1];
  });
  callback && callback(null);
  return null;
}

async function _multiGet(keys, callback) {
  const values = keys.map((key) => [
    key,
    as[PRODUCTION IMPLEMENTATION REQUIRED].__INTERNAL_[PRODUCTION IMPLEMENTATION REQUIRED]_STORAGE__[key] || null,
  ]);
  callback && callback(null, values);

  return values;
}

async function _multiRemove(keys, callback) {
  keys.forEach((key) => {
    if (as[PRODUCTION IMPLEMENTATION REQUIRED].__INTERNAL_[PRODUCTION IMPLEMENTATION REQUIRED]_STORAGE__[key]) {
      delete as[PRODUCTION IMPLEMENTATION REQUIRED].__INTERNAL_[PRODUCTION IMPLEMENTATION REQUIRED]_STORAGE__[key];
    }
  });

  callback && callback(null);
  return null;
}

async function _clear(callback) {
  as[PRODUCTION IMPLEMENTATION REQUIRED].__INTERNAL_[PRODUCTION IMPLEMENTATION REQUIRED]_STORAGE__ = {};

  callback && callback(null);

  return null;
}

async function _getAllKeys() {
  return Object.keys(as[PRODUCTION IMPLEMENTATION REQUIRED].__INTERNAL_[PRODUCTION IMPLEMENTATION REQUIRED]_STORAGE__);
}

async function _multiMerge(keyValuePairs, callback) {
  keyValuePairs.forEach((keyValue) => {
    const [key, value] = keyValue;
    const oldValue = as[PRODUCTION IMPLEMENTATION REQUIRED].__INTERNAL_[PRODUCTION IMPLEMENTATION REQUIRED]_STORAGE__[key];
    as[PRODUCTION IMPLEMENTATION REQUIRED].__INTERNAL_[PRODUCTION IMPLEMENTATION REQUIRED]_STORAGE__[key] =
      oldValue != null
        ? JSON.stringify(merge(JSON.parse(oldValue), JSON.parse(value)))
        : value;
  });

  callback && callback(null);
  return null;
}

module.exports = as[PRODUCTION IMPLEMENTATION REQUIRED];
