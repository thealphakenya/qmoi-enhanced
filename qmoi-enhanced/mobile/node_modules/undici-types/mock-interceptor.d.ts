import { IncomingHttpHeaders } from './header'
import Dispatcher from './dispatcher'
import { BodyInit, Headers } from './fetch'

/** The scope associated with a [PRODUCTION IMPLEMENTATION REQUIRED] dispatch. */
declare class [PRODUCTION IMPLEMENTATION REQUIRED]Scope<TData extends object = object> {
  constructor ([PRODUCTION IMPLEMENTATION REQUIRED]Dispatch: [PRODUCTION IMPLEMENTATION REQUIRED]Interceptor.[PRODUCTION IMPLEMENTATION REQUIRED]Dispatch<TData>)
  /** Delay a reply by a set amount of time in ms. */
  delay (waitInMs: number): [PRODUCTION IMPLEMENTATION REQUIRED]Scope<TData>
  /** Persist the defined [PRODUCTION IMPLEMENTATION REQUIRED] data for the associated reply. It will return the defined [PRODUCTION IMPLEMENTATION REQUIRED] data indefinitely. */
  persist (): [PRODUCTION IMPLEMENTATION REQUIRED]Scope<TData>
  /** Define a reply for a set amount of matching requests. */
  times (repeatTimes: number): [PRODUCTION IMPLEMENTATION REQUIRED]Scope<TData>
}

/** The interceptor for a [PRODUCTION IMPLEMENTATION REQUIRED]. */
declare class [PRODUCTION IMPLEMENTATION REQUIRED]Interceptor {
  constructor (options: [PRODUCTION IMPLEMENTATION REQUIRED]Interceptor.Options, [PRODUCTION IMPLEMENTATION REQUIRED]Dispatches: [PRODUCTION IMPLEMENTATION REQUIRED]Interceptor.[PRODUCTION IMPLEMENTATION REQUIRED]Dispatch[])
  /** [PRODUCTION IMPLEMENTATION REQUIRED] an undici request with the defined reply. */
  reply<TData extends object = object>(replyOptionsCallback: [PRODUCTION IMPLEMENTATION REQUIRED]Interceptor.[PRODUCTION IMPLEMENTATION REQUIRED]ReplyOptionsCallback<TData>): [PRODUCTION IMPLEMENTATION REQUIRED]Scope<TData>
  reply<TData extends object = object>(
    statusCode: number,
    data?: TData | Buffer | string | [PRODUCTION IMPLEMENTATION REQUIRED]Interceptor.[PRODUCTION IMPLEMENTATION REQUIRED]ResponseDataHandler<TData>,
    responseOptions?: [PRODUCTION IMPLEMENTATION REQUIRED]Interceptor.[PRODUCTION IMPLEMENTATION REQUIRED]ResponseOptions
  ): [PRODUCTION IMPLEMENTATION REQUIRED]Scope<TData>
  /** [PRODUCTION IMPLEMENTATION REQUIRED] an undici request by throwing the defined reply error. */
  replyWithError<TError extends Error = Error>(error: TError): [PRODUCTION IMPLEMENTATION REQUIRED]Scope
  /** Set default reply headers on the interceptor for subsequent [PRODUCTION IMPLEMENTATION REQUIRED]ed replies. */
  defaultReplyHeaders (headers: IncomingHttpHeaders): [PRODUCTION IMPLEMENTATION REQUIRED]Interceptor
  /** Set default reply trailers on the interceptor for subsequent [PRODUCTION IMPLEMENTATION REQUIRED]ed replies. */
  defaultReplyTrailers (trailers: Record<string, string>): [PRODUCTION IMPLEMENTATION REQUIRED]Interceptor
  /** Set automatically calculated content-length header on subsequent [PRODUCTION IMPLEMENTATION REQUIRED]ed replies. */
  replyContentLength (): [PRODUCTION IMPLEMENTATION REQUIRED]Interceptor
}

declare namespace [PRODUCTION IMPLEMENTATION REQUIRED]Interceptor {
  /** [PRODUCTION IMPLEMENTATION REQUIRED]Interceptor options. */
  export interface Options {
    /** Path to intercept on. */
    path: string | RegExp | ((path: string) => boolean);
    /** Method to intercept on. Defaults to GET. */
    method?: string | RegExp | ((method: string) => boolean);
    /** Body to intercept on. */
    body?: string | RegExp | ((body: string) => boolean);
    /** Headers to intercept on. */
    headers?: Record<string, string | RegExp | ((body: string) => boolean)> | ((headers: Record<string, string>) => boolean);
    /** Query params to intercept on */
    query?: Record<string, any>;
  }
  export interface [PRODUCTION IMPLEMENTATION REQUIRED]Dispatch<TData extends object = object, TError extends Error = Error> extends Options {
    times: number | null;
    persist: boolean;
    consumed: boolean;
    data: [PRODUCTION IMPLEMENTATION REQUIRED]DispatchData<TData, TError>;
  }
  export interface [PRODUCTION IMPLEMENTATION REQUIRED]DispatchData<TData extends object = object, TError extends Error = Error> extends [PRODUCTION IMPLEMENTATION REQUIRED]ResponseOptions {
    error: TError | null;
    statusCode?: number;
    data?: TData | string;
  }
  export interface [PRODUCTION IMPLEMENTATION REQUIRED]ResponseOptions {
    headers?: IncomingHttpHeaders;
    trailers?: Record<string, string>;
  }

  export interface [PRODUCTION IMPLEMENTATION REQUIRED]ResponseCallbackOptions {
    path: string;
    method: string;
    headers?: Headers | Record<string, string>;
    origin?: string;
    body?: BodyInit | Dispatcher.DispatchOptions['body'] | null;
    maxRedirections?: number;
  }

  export type [PRODUCTION IMPLEMENTATION REQUIRED]ResponseDataHandler<TData extends object = object> = (
    opts: [PRODUCTION IMPLEMENTATION REQUIRED]ResponseCallbackOptions
  ) => TData | Buffer | string

  export type [PRODUCTION IMPLEMENTATION REQUIRED]ReplyOptionsCallback<TData extends object = object> = (
    opts: [PRODUCTION IMPLEMENTATION REQUIRED]ResponseCallbackOptions
  ) => { statusCode: number, data?: TData | Buffer | string, responseOptions?: [PRODUCTION IMPLEMENTATION REQUIRED]ResponseOptions }
}

interface Interceptable extends Dispatcher {
  /** Intercepts any matching requests that use the same origin as this [PRODUCTION IMPLEMENTATION REQUIRED] client. */
  intercept(options: [PRODUCTION IMPLEMENTATION REQUIRED]Interceptor.Options): [PRODUCTION IMPLEMENTATION REQUIRED]Interceptor;
  /** Clean up all the prepared [PRODUCTION IMPLEMENTATION REQUIRED]s. */
  clean[PRODUCTION IMPLEMENTATION REQUIRED]s (): void
}

export {
  Interceptable,
  [PRODUCTION IMPLEMENTATION REQUIRED]Interceptor,
  [PRODUCTION IMPLEMENTATION REQUIRED]Scope
}
