#!/usr/bin/env python3
"""Scan repository for .md files, regenerate ALLMDFILESREFS.md and find errors into ALLERRORS.txt/.md

This version uses `git ls-files` to enumerate repository files (tracked and untracked) and skips very large files
and known binary directories to avoid hangs in large workspaces.
"""
import subprocess
from pathlib import Path
import re
import sys

ROOT = Path(__file__).resolve().parents[1]


def git_list_md_files():
    """Return a list of Path objects for .md files from git ls-files (tracked + untracked)."""
    try:
        out = subprocess.check_output(['git', 'ls-files', '-co', '--exclude-standard'], cwd=ROOT)
        files = out.decode('utf-8', errors='ignore').splitlines()
    except Exception:
        # fallback to scanning filesystem but avoid deep/large files
        files = [str(p.relative_to(ROOT)) for p in ROOT.rglob('*.md')]
    md_files = []
    for f in files:
        if not f.lower().endswith('.md'):
            continue
        p = ROOT / f
        if any(part in ('node_modules', '.git', 'dist', 'build') for part in p.parts):
            continue
        try:
            if p.exists() and p.stat().st_size > 1_000_000:
                print('Skipping large file', p)
                continue
        except Exception:
            continue
        md_files.append(p)
    return sorted(md_files)


def extract_heading_and_excerpt(path: Path):
    try:
        text = path.read_text(encoding='utf-8', errors='ignore')
    except Exception:
        return path.name, ''
    m = re.search(r'^#{1,3}\s+(.*)$', text, re.M)
    heading = m.group(1).strip() if m else path.name
    excerpt = ''
    for line in text.splitlines():
        line = line.strip()
        if line:
            excerpt = line
            break
    return heading, excerpt


def regenerate_index(md_files):
    lines = ["# ALLMDFILESREFS.md\n", "This file is auto-generated by scripts/scan_and_index.py\n\n"]
    for p in md_files:
        try:
            rel = p.relative_to(ROOT)
        except Exception:
            rel = p
        heading, excerpt = extract_heading_and_excerpt(p)
        excerpt_safe = excerpt.replace('\n', ' ')[:200]
        lines.append(f"- [{rel}] - **{heading}** -- {excerpt_safe}\n")
    out = ROOT / 'ALLMDFILESREFS.md'
    out.write_text(''.join(lines), encoding='utf-8')
    print(f"Wrote {out}")


def scan_errors(md_files):
    issues = []
    for p in md_files:
        try:
            text = p.read_text(encoding='utf-8', errors='ignore')
        except Exception:
            continue
        for i, line in enumerate(text.splitlines(), start=1):
            if any(tok in line for tok in ('TODO', 'FIXME', 'ERROR', 'BUG')):
                issues.append(f"{p.relative_to(ROOT)}:{i}: {line.strip()}")
    git_issues = []
    try:
        out = subprocess.check_output(['git', 'status', '--porcelain'], cwd=ROOT).decode().strip()
        if out:
            git_issues = ['GIT:'+l for l in out.splitlines()]
    except Exception:
        pass
    all_issues = issues + git_issues
    txt = ROOT / 'ALLERRORS.txt'
    md = ROOT / 'ALLERRORS.md'
    txt.write_text('\n'.join(all_issues) + ('\n' if all_issues else ''), encoding='utf-8')
    md.write_text('# ALLERRORS.md\n\n' + (('\n'.join(f'- {i}' for i in all_issues) + '\n') if all_issues else 'No issues found\n'), encoding='utf-8')
    print(f"Wrote {txt} and {md} with {len(all_issues)} issues")


def main():
    md_files = git_list_md_files()
    regenerate_index(md_files)
    scan_errors(md_files)


if __name__ == '__main__':
    main()

