#!/usr/bin/env python3
"""Simple project scanner that writes ALLERRORS.txt and ALLERRORS.md

Checks performed:
- Grep for TODO, FIXME
- Quick Python syntax check for .py files
- List untracked git files
"""
import subprocess
from pathlib import Path
ROOT = Path('.')
errors = []

# grep for TODO/FIXME
IGNORED = ['node_modules', '.git', 'qmoi-enhanced/mobile/node_mod', 'qmoi-enhanced/qmoi-enhanced/mobile/node_mod']
for p in ROOT.rglob('*'):
    if any(ig in p.parts for ig in IGNORED):
        continue
    if p.is_file() and p.suffix in ['.py', '.js', '.ts', '.md', '.txt']:
        try:
            for i, line in enumerate(p.read_text(encoding='utf-8', errors='ignore').splitlines(), start=1):
                if 'TODO' in line or 'FIXME' in line:
                    errors.append(f'{p}:{i}: {line.strip()}')
        except Exception:
            pass

# python syntax checks
for p in ROOT.rglob('*.py'):
    try:
        import py_compile
        py_compile.compile(str(p), doraise=True)
    except Exception as e:
        errors.append(f'PY_SYNTAX: {p}: {e}')

# git status untracked/staged
try:
    out = subprocess.check_output(['git','status','--porcelain'], text=True)
    if out.strip():
        errors.append('GIT_STATUS:\n' + out)
except Exception:
    errors.append('GIT_STATUS: git not available')

ALLTXT = Path('ALLERRORS.txt')
ALLMD = Path('ALLERRORS.md')
ALLTXT.write_text('\n'.join(errors) + '\n')
ALLMD.write_text('# ALLERRORS\n\n' + '\n'.join(f'- {e}' for e in errors) + '\n')
print('Wrote', ALLTXT, ALLMD)
#!/usr/bin/env python3
"""
Simple repository scanner that finds Markdown files, extracts excerpts,
and searches code for common TODO/FIXME markers. Writes results to
ALLMDFILESREFS.md and ALLERRORS.txt / ALLERRORS.md.

This is intentionally lightweight and has no external dependencies.
"""
import os
from pathlib import Path
import re

ROOT = Path(__file__).resolve().parent.parent

def find_md_files(root: Path):
    return sorted(root.rglob('*.md'))

def excerpt(path: Path, max_lines=6):
    try:
        text = path.read_text(encoding='utf-8', errors='ignore')
    except Exception:
        return ''
    lines = [l.rstrip() for l in text.splitlines() if l.strip()]
    return '\n'.join(lines[:max_lines])

def scan_todos_and_errors(root: Path):
    patterns = [re.compile(r"TODO"), re.compile(r"FIXME"), re.compile(r"ERROR"), re.compile(r"@error", re.I)]
    findings = []
    for p in root.rglob('*'):
        if p.is_file() and p.suffix not in ['.pyc', '.png', '.jpg', '.jpeg', '.gif']:
            try:
                txt = p.read_text(encoding='utf-8', errors='ignore')
            except Exception:
                continue
            for i, line in enumerate(txt.splitlines(), 1):
                for pat in patterns:
                    if pat.search(line):
                        findings.append(f"{p.relative_to(root)}:{i}: {line.strip()}")
    return findings

def main():
    md_files = find_md_files(ROOT)

    allmd_path = ROOT / 'ALLMDFILESREFS.md'
    with allmd_path.open('w', encoding='utf-8') as f:
        f.write('# ALLMDFILESREFS\n\n')
        f.write('Autogenerated list of Markdown files with excerpts.\n\n')
        for m in md_files:
            rel = m.relative_to(ROOT)
            f.write(f'## {rel}\n\n')
            ex = excerpt(m, max_lines=8)
            if ex:
                f.write('``\n')
                f.write(ex)
                f.write('\n``\n\n')
            else:
                f.write('_(unable to read excerpt)_\n\n')

    errors = scan_todos_and_errors(ROOT)
    txt_path = ROOT / 'ALLERRORS.txt'
    md_path = ROOT / 'ALLERRORS.md'
    with txt_path.open('w', encoding='utf-8') as f:
        for e in errors:
            f.write(e + '\n')

    with md_path.open('w', encoding='utf-8') as f:
        f.write('# ALLERRORS\n\n')
        if not errors:
            f.write('No TODO/FIXME/ERROR markers found by scripts/scan_errors.py.\n')
        else:
            for e in errors:
                f.write(f'- `{e}`\n')

if __name__ == '__main__':
    main()
