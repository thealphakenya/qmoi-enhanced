#!/usr/bin/env node

import https from 'https';
import fs from 'fs';
import path from 'path';

class GitLabNotificationService {
  constructor() {
    this.gitlabToken = process.env.GITLAB_TOKEN || process.env.GITLAB_ACCESS_TOKEN;
    this.gitlabUrl = process.env.GITLAB_URL || 'https://gitlab.com';
    this.projectId = process.env.GITLAB_PROJECT_ID;
    this.branch = process.env.CI_COMMIT_REF_NAME || 'main';
    this.commitSha = process.env.CI_COMMIT_SHA;
    this.jobId = process.env.CI_JOB_ID;
    this.pipelineId = process.env.CI_PIPELINE_ID;
    
    this.logFile = path.join(process.cwd(), 'logs', 'gitlab-notifications.log');
    this.ensureLogDir();
  }

  ensureLogDir() {
    const logDir = path.dirname(this.logFile);
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }
  }

  log(message, level = 'INFO') {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] [${level}] ${message}\n`;
    fs.appendFileSync(this.logFile, logEntry);
    console.log(`[${level}] ${message}`);
  }

  async makeGitLabRequest(endpoint, method = 'GET', body = null) {
    return new Promise((resolve, reject) => {
      const options = {
        hostname: new URL(this.gitlabUrl).hostname,
        port: 443,
        path: `/api/v4${endpoint}`,
        method,
        headers: {
          'Authorization': `Bearer ${this.gitlabToken}`,
          'Content-Type': 'application/json',
          'User-Agent': 'QMOI-GitLab-Notifications/1.0'
        }
      };

      const req = https.request(options, (res) => {
        let data = '';
        res.on('data', chunk => data += chunk);
        res.on('end', () => {
          try {
            const jsonData = JSON.parse(data);
            resolve(jsonData);
          } catch (e) {
            resolve(data);
          }
        });
      });

      req.on('error', reject);
      if (body) {
        req.write(JSON.stringify(body));
      }
      req.end();
    });
  }

  async createGitLabIssue(title, description, labels = ['qmoi', 'notification']) {
    try {
      const issue = await this.makeGitLabRequest(`/projects/${this.projectId}/issues`, 'POST', {
        title,
        description,
        labels: labels.join(','),
        confidential: false
      });
      this.log(`Created GitLab issue: ${issue.iid} - ${title}`);
      return issue;
    } catch (error) {
      this.log(`Failed to create GitLab issue: ${error.message}`, 'ERROR');
      return null;
    }
  }

  async addGitLabComment(comment, mergeRequestId = null) {
    try {
      const mrId = mergeRequestId || this.pipelineId;
      await this.makeGitLabRequest(`/projects/${this.projectId}/merge_requests/${mrId}/notes`, 'POST', {
        body: comment
      });
      this.log(`Added GitLab comment to MR ${mrId}`);
    } catch (error) {
      this.log(`Failed to add GitLab comment: ${error.message}`, 'ERROR');
    }
  }

  async updateGitLabStatus(status, description) {
    try {
      await this.makeGitLabRequest(`/projects/${this.projectId}/status_checks/${this.commitSha}`, 'POST', {
        state: status,
        description,
        target_url: `${this.gitlabUrl}/${this.projectId}/-/jobs/${this.jobId}`
      });
      this.log(`Updated GitLab status: ${status} - ${description}`);
    } catch (error) {
      this.log(`Failed to update GitLab status: ${error.message}`, 'ERROR');
    }
  }

  async sendPipelineNotification(type, data = {}) {
    try {
      const timestamp = new Date().toISOString();
      const pipelineUrl = `${this.gitlabUrl}/${this.projectId}/-/pipelines/${this.pipelineId}`;
      const jobUrl = `${this.gitlabUrl}/${this.projectId}/-/jobs/${this.jobId}`;
      
      let title, description, labels;
      
      switch (type) {
        case 'pipeline_started':
          title = `ðŸš€ QMOI Pipeline Started - ${timestamp}`;
          description = `## QMOI Pipeline Started

### Pipeline Details:
- **Branch**: ${this.branch}
- **Commit**: ${this.commitSha}
- **Pipeline ID**: ${this.pipelineId}
- **Job ID**: ${this.jobId}
- **Timestamp**: ${timestamp}

### Pipeline URL:
${pipelineUrl}

### Job URL:
${jobUrl}

### Status:
Pipeline has started and is running through all stages.

---
*Generated by QMOI Notification Service*`;
          labels = ['qmoi', 'pipeline', 'started'];
          break;
          
        case 'pipeline_success':
          title = `âœ… QMOI Pipeline Success - ${timestamp}`;
          description = `## QMOI Pipeline Completed Successfully

### Pipeline Details:
- **Branch**: ${this.branch}
- **Commit**: ${this.commitSha}
- **Pipeline ID**: ${this.pipelineId}
- **Job ID**: ${this.jobId}
- **Timestamp**: ${timestamp}

### Results:
- âœ… Auto-setup completed
- âœ… Tests passed
- âœ… Build successful
- âœ… Deployment completed
- âœ… Notifications sent

### Pipeline URL:
${pipelineUrl}

### Job URL:
${jobUrl}

### Next Steps:
- Review the deployment
- Monitor application health
- Run additional validation tests

---
*Generated by QMOI Notification Service*`;
          labels = ['qmoi', 'pipeline', 'success'];
          break;
          
        case 'pipeline_failed':
          title = `âŒ QMOI Pipeline Failed - ${timestamp}`;
          description = `## QMOI Pipeline Failed

### Pipeline Details:
- **Branch**: ${this.branch}
- **Commit**: ${this.commitSha}
- **Pipeline ID**: ${this.pipelineId}
- **Job ID**: ${this.jobId}
- **Timestamp**: ${timestamp}

### Error Details:
\`\`\`
${data.error || 'Unknown error occurred'}
\`\`\`

### Pipeline URL:
${pipelineUrl}

### Job URL:
${jobUrl}

### Recovery Steps:
1. Check the pipeline logs
2. Review the error details
3. Fix the identified issues
4. Re-run the pipeline
5. Monitor for similar errors

### Common Issues:
- Missing dependencies
- Build configuration errors
- Test failures
- Deployment issues
- Environment problems

---
*Generated by QMOI Notification Service*`;
          labels = ['qmoi', 'pipeline', 'failed', 'needs-attention'];
          break;
          
        case 'auto_fix_applied':
          title = `ðŸ”§ QMOI Auto-Fix Applied - ${timestamp}`;
          description = `## QMOI Auto-Fix Applied

### Fix Details:
- **Branch**: ${this.branch}
- **Commit**: ${this.commitSha}
- **Pipeline ID**: ${this.pipelineId}
- **Job ID**: ${this.jobId}
- **Timestamp**: ${timestamp}

### Fixes Applied:
${data.fixes ? data.fixes.map(fix => `- ${fix}`).join('\n') : '- Various automated fixes'}

### Pipeline URL:
${pipelineUrl}

### Job URL:
${jobUrl}

### Fix Summary:
The QMOI automation system detected and automatically fixed issues in the pipeline.

### Next Steps:
- Review the applied fixes
- Verify the fixes resolved the issues
- Monitor for similar problems

---
*Generated by QMOI Notification Service*`;
          labels = ['qmoi', 'auto-fix', 'applied'];
          break;
          
        case 'deployment_success':
          title = `ðŸš€ QMOI Deployment Success - ${timestamp}`;
          description = `## QMOI Deployment Completed Successfully

### Deployment Details:
- **Branch**: ${this.branch}
- **Commit**: ${this.commitSha}
- **Pipeline ID**: ${this.pipelineId}
- **Job ID**: ${this.jobId}
- **Timestamp**: ${timestamp}
- **Environment**: ${data.environment || 'Production'}

### Deployment Results:
- âœ… Build artifacts created
- âœ… GitLab release published
- âœ… All tests passed
- âœ… Auto-setup completed

### Access Points:
- **Release**: ${this.gitlabUrl}/${this.projectId}/-/releases
- **Artifacts**: ${this.gitlabUrl}/${this.projectId}/-/jobs/${this.jobId}/artifacts/browse
- **Pipeline**: ${pipelineUrl}

### Next Steps:
- Monitor application health
- Run smoke tests
- Update documentation
- Notify stakeholders

---
*Generated by QMOI Notification Service*`;
          labels = ['qmoi', 'deployment', 'success'];
          break;
          
        case 'deployment_failed':
          title = `âŒ QMOI Deployment Failed - ${timestamp}`;
          description = `## QMOI Deployment Failed

### Deployment Details:
- **Branch**: ${this.branch}
- **Commit**: ${this.commitSha}
- **Pipeline ID**: ${this.pipelineId}
- **Job ID**: ${this.jobId}
- **Timestamp**: ${timestamp}
- **Environment**: ${data.environment || 'Production'}

### Error Details:
\`\`\`
${data.error || 'Unknown deployment error'}
\`\`\`

### Pipeline URL:
${pipelineUrl}

### Job URL:
${jobUrl}

### Immediate Actions:
1. **Rollback**: Revert to previous stable version
2. **Investigate**: Check deployment logs
3. **Fix**: Address the root cause
4. **Test**: Verify fix locally
5. **Redeploy**: Trigger new deployment

### Common Deployment Issues:
- Environment configuration
- Resource constraints
- Network connectivity
- Permission issues
- Build artifact problems

---
*Generated by QMOI Notification Service*`;
          labels = ['qmoi', 'deployment', 'failed', 'needs-rollback'];
          break;
          
        case 'test_failure':
          title = `ðŸ§ª QMOI Test Failure - ${timestamp}`;
          description = `## QMOI Test Failure Report

### Test Details:
- **Branch**: ${this.branch}
- **Commit**: ${this.commitSha}
- **Pipeline ID**: ${this.pipelineId}
- **Job ID**: ${this.jobId}
- **Timestamp**: ${timestamp}

### Test Categories:
- Unit Tests: \`npm test\`
- UI Tests: \`npm run test:ui\`
- E2E Tests: \`npm run test:e2e\`

### Error Details:
\`\`\`
${data.error || 'Test execution failed'}
\`\`\`

### Pipeline URL:
${pipelineUrl}

### Job URL:
${jobUrl}

### Debugging Steps:
1. Run tests locally: \`npm test\`
2. Check test coverage: \`npm run test:coverage\`
3. Run specific test: \`npm test -- --testNamePattern="test name"\`
4. Check test environment: \`npm run test:debug\`

### Common Test Issues:
- Missing test dependencies
- Environment configuration issues
- Async test timing problems
- Mock/stub configuration errors

---
*Generated by QMOI Notification Service*`;
          labels = ['qmoi', 'test', 'failed', 'needs-review'];
          break;
          
        case 'build_failure':
          title = `ðŸ—ï¸ QMOI Build Failure - ${timestamp}`;
          description = `## QMOI Build Failure Report

### Build Details:
- **Branch**: ${this.branch}
- **Commit**: ${this.commitSha}
- **Pipeline ID**: ${this.pipelineId}
- **Job ID**: ${this.jobId}
- **Timestamp**: ${timestamp}

### Build Process:
- TypeScript compilation
- Bundle generation
- Asset optimization
- Production build

### Error Details:
\`\`\`
${data.error || 'Build process failed'}
\`\`\`

### Pipeline URL:
${pipelineUrl}

### Job URL:
${jobUrl}

### Debugging Steps:
1. Check TypeScript errors: \`npx tsc --noEmit\`
2. Verify dependencies: \`npm ls\`
3. Clear build cache: \`npm run build:clean\`
4. Check build config: Review webpack/build configuration

### Common Build Issues:
- TypeScript compilation errors
- Missing dependencies
- Import/export issues
- Asset loading problems
- Environment variable issues

---
*Generated by QMOI Notification Service*`;
          labels = ['qmoi', 'build', 'failed', 'needs-fix'];
          break;
          
        default:
          title = `ðŸ“¢ QMOI Notification - ${timestamp}`;
          description = `## QMOI Notification

### Details:
- **Branch**: ${this.branch}
- **Commit**: ${this.commitSha}
- **Pipeline ID**: ${this.pipelineId}
- **Job ID**: ${this.jobId}
- **Timestamp**: ${timestamp}
- **Type**: ${type}

### Pipeline URL:
${pipelineUrl}

### Job URL:
${jobUrl}

---
*Generated by QMOI Notification Service*`;
          labels = ['qmoi', 'notification'];
      }
      
      // Create GitLab issue
      const issue = await this.createGitLabIssue(title, description, labels);
      
      // Add comment to merge request if available
      if (this.pipelineId) {
        await this.addGitLabComment(description, this.pipelineId);
      }
      
      // Update GitLab status
      const statusMap = {
        'pipeline_started': 'running',
        'pipeline_success': 'success',
        'pipeline_failed': 'failed',
        'auto_fix_applied': 'success',
        'deployment_success': 'success',
        'deployment_failed': 'failed',
        'test_failure': 'failed',
        'build_failure': 'failed'
      };
      
      const status = statusMap[type] || 'running';
      await this.updateGitLabStatus(status, title);
      
      this.log(`Pipeline notification sent: ${type}`);
      return issue;
      
    } catch (error) {
      this.log(`Failed to send pipeline notification: ${error.message}`, 'ERROR');
      throw error;
    }
  }

  async sendErrorNotification(error, context = {}) {
    try {
      const timestamp = new Date().toISOString();
      const errorTitle = `âŒ QMOI Error - ${context.type || 'Unknown'} - ${timestamp}`;
      
      const errorDescription = `## QMOI Error Report

### Error Details:
- **Type**: ${context.type || 'Unknown'}
- **Branch**: ${this.branch}
- **Commit**: ${this.commitSha}
- **Pipeline ID**: ${this.pipelineId}
- **Job ID**: ${this.jobId}
- **Timestamp**: ${timestamp}

### Error Message:
\`\`\`
${error.message}
\`\`\`

### Error Stack:
\`\`\`
${error.stack || 'No stack trace available'}
\`\`\`

### Context:
${Object.entries(context).map(([key, value]) => `- **${key}**: ${value}`).join('\n')}

### Recovery Steps:
1. Review the error details
2. Check the automation logs
3. Identify the root cause
4. Apply necessary fixes
5. Re-run the affected process

### Support:
- Check the automation logs for detailed information
- Review the created GitLab issues for specific fixes
- Contact the development team if needed

---
*Generated by QMOI Notification Service*`;

      const labels = ['qmoi', 'error', context.type || 'unknown', 'needs-attention'];
      
      const issue = await this.createGitLabIssue(errorTitle, errorDescription, labels);
      
      if (this.pipelineId) {
        await this.addGitLabComment(errorDescription, this.pipelineId);
      }
      
      await this.updateGitLabStatus('failed', errorTitle);
      
      this.log(`Error notification sent: ${context.type || 'Unknown'}`);
      return issue;
      
    } catch (notificationError) {
      this.log(`Failed to send error notification: ${notificationError.message}`, 'ERROR');
      throw notificationError;
    }
  }

  async sendSuccessNotification(context = {}) {
    try {
      const timestamp = new Date().toISOString();
      const successTitle = `âœ… QMOI Success - ${context.type || 'Operation'} - ${timestamp}`;
      
      const successDescription = `## QMOI Success Report

### Success Details:
- **Type**: ${context.type || 'Operation'}
- **Branch**: ${this.branch}
- **Commit**: ${this.commitSha}
- **Pipeline ID**: ${this.pipelineId}
- **Job ID**: ${this.jobId}
- **Timestamp**: ${timestamp}

### Results:
${Object.entries(context).map(([key, value]) => `- **${key}**: ${value}`).join('\n')}

### Pipeline URL:
${this.gitlabUrl}/${this.projectId}/-/pipelines/${this.pipelineId}

### Job URL:
${this.gitlabUrl}/${this.projectId}/-/jobs/${this.jobId}

### Next Steps:
- Review the results
- Monitor for any issues
- Continue with the next phase
- Update documentation if needed

---
*Generated by QMOI Notification Service*`;

      const labels = ['qmoi', 'success', context.type || 'operation'];
      
      const issue = await this.createGitLabIssue(successTitle, successDescription, labels);
      
      if (this.pipelineId) {
        await this.addGitLabComment(successDescription, this.pipelineId);
      }
      
      await this.updateGitLabStatus('success', successTitle);
      
      this.log(`Success notification sent: ${context.type || 'Operation'}`);
      return issue;
      
    } catch (error) {
      this.log(`Failed to send success notification: ${error.message}`, 'ERROR');
      throw error;
    }
  }
}

// Main execution
async function main() {
  const notificationService = new GitLabNotificationService();
  
  try {
    const args = process.argv.slice(2);
    const command = args[0];
    const data = args[1] ? JSON.parse(args[1]) : {};
    
    switch (command) {
      case '--pipeline-started':
        await notificationService.sendPipelineNotification('pipeline_started', data);
        break;
      case '--pipeline-success':
        await notificationService.sendPipelineNotification('pipeline_success', data);
        break;
      case '--pipeline-failed':
        await notificationService.sendPipelineNotification('pipeline_failed', data);
        break;
      case '--auto-fix-applied':
        await notificationService.sendPipelineNotification('auto_fix_applied', data);
        break;
      case '--deployment-success':
        await notificationService.sendPipelineNotification('deployment_success', data);
        break;
      case '--deployment-failed':
        await notificationService.sendPipelineNotification('deployment_failed', data);
        break;
      case '--test-failure':
        await notificationService.sendPipelineNotification('test_failure', data);
        break;
      case '--build-failure':
        await notificationService.sendPipelineNotification('build_failure', data);
        break;
      case '--error':
        const error = new Error(data.message || 'Unknown error');
        error.stack = data.stack;
        await notificationService.sendErrorNotification(error, data);
        break;
      case '--success':
        await notificationService.sendSuccessNotification(data);
        break;
      default:
        console.log('QMOI GitLab Notification Service');
        console.log('Usage:');
        console.log('  --pipeline-started [data]    Send pipeline started notification');
        console.log('  --pipeline-success [data]    Send pipeline success notification');
        console.log('  --pipeline-failed [data]     Send pipeline failed notification');
        console.log('  --auto-fix-applied [data]    Send auto-fix applied notification');
        console.log('  --deployment-success [data]  Send deployment success notification');
        console.log('  --deployment-failed [data]   Send deployment failed notification');
        console.log('  --test-failure [data]        Send test failure notification');
        console.log('  --build-failure [data]       Send build failure notification');
        console.log('  --error [data]               Send error notification');
        console.log('  --success [data]             Send success notification');
        break;
    }
    
  } catch (error) {
    notificationService.log(`Notification service failed: ${error.message}`, 'ERROR');
    process.exit(1);
  }
}

// Export for use in other scripts
module.exports = { GitLabNotificationService };

// Run if this script is executed directly
if (require.main === module) {
  main();
} 