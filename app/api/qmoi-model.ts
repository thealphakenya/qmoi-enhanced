import type { NextApiRequest, NextApiResponse } from 'next';
import fs from 'fs';
import path from 'path';

// In-memory AI task log (replace with persistent DB in production)
let aiTaskLog: any[] = [];
const LOG_PATH = '/workspaces/Alpha-Q-ai/qmoi-tasks-log.jsonl';

// Helper to persist log
function persistLog() {
  fs.writeFileSync(LOG_PATH, aiTaskLog.map((t) => JSON.stringify(t)).join('\n'));
}
// Helper to load log
function loadLog() {
  if (fs.existsSync(LOG_PATH)) {
    aiTaskLog = fs.readFileSync(LOG_PATH, 'utf8').split('\n').filter(Boolean).map((line: string) => JSON.parse(line));
  }
}

// Simulate Qmoi model enhancement
async function enhanceModel(desc: string) {
  const task = { id: Date.now(), type: 'enhancement', desc, status: 'completed', timestamp: new Date().toISOString() };
  aiTaskLog.push(task);
  persistLog();
  return task;
}

// Simulate file upload handling
async function handleFileUpload(file: any) {
  // Save file to uploads dir (create if not exists)
  const uploadsDir = '/workspaces/Alpha-Q-ai/uploads';
  if (!fs.existsSync(uploadsDir)) fs.mkdirSync(uploadsDir);
  const filePath = path.join(uploadsDir, file.originalname);
  fs.writeFileSync(filePath, file.buffer);
  const task = { id: Date.now(), type: 'file-upload', file: file.originalname, status: 'completed', timestamp: new Date().toISOString() };
  aiTaskLog.push(task);
  persistLog();
  return task;
}

// Simulate auto-discover/build/use extension for a project
async function autoDiscoverAndBuildExtension(projectType: string) {
  // Example: choose best extension/package for project type
  const ext = projectType === 'game' ? 'phaser' : projectType === 'animation' ? 'three' : projectType === 'music' ? 'tone' : 'latest-ai-lib';
  // Simulate Colab job
  const job = {
    id: Date.now(),
    type: 'build-extension',
    name: ext,
    status: 'success',
    started: new Date().toISOString(),
    finished: new Date().toISOString(),
    result: `Auto-built extension ${ext} for ${projectType}`,
  };
  // Log as AI task
  aiTaskLog.push({ id: job.id, type: 'auto-extension', desc: `Auto-built ${ext} for ${projectType}`, status: 'completed', timestamp: job.finished });
  persistLog();
  return job;
}

// Simulate creative file generation
async function creativeFileGen(type: string, details: any) {
  // Use latest packages, internet search, and AI creativity
  const file = {
    id: Date.now(),
    type: 'creative-file',
    fileType: type,
    details,
    status: 'completed',
    url: `/generated/${type}-${Date.now()}`,
    timestamp: new Date().toISOString(),
  };
  aiTaskLog.push(file);
  persistLog();
  return file;
}

// --- User Timezone Preference ---
let userTimeZone: string = 'UTC';
function setUserTimeZone(tz: string) {
  userTimeZone = tz;
  // Optionally persist to user profile or DB
}
function getUserTimeZone() {
  return userTimeZone;
}

// --- Enhanced Project Creation with README.md and Thoroughness ---
async function createProject(projectName: string, files: any[], userPrefs: any = {}) {
  const projectDir = `/workspaces/Alpha-Q-ai/projects/${projectName}`;
  if (!fs.existsSync(projectDir)) fs.mkdirSync(projectDir, { recursive: true });
  files.forEach(f => {
    const filePath = path.join(projectDir, f.name);
    fs.writeFileSync(filePath, f.content);
  });
  // Always generate a thorough README.md
  const readmeContent = `# ${projectName}\n\nProject generated by Alpha-Q AI.\n\n## Description\n${userPrefs.description || 'No description provided.'}\n\n## Files\n${files.map(f => '- ' + f.name).join('\n')}\n\n## Created\n${new Date().toLocaleString(getUserTimeZone())}\n`;
  const readmePath = path.join(projectDir, 'README.md');
  fs.writeFileSync(readmePath, readmeContent);
  // Log project creation
  aiTaskLog.push({ id: Date.now(), type: 'project-init', project: projectName, files: files.map(f => f.name), status: 'completed', timestamp: new Date().toISOString(), timeZone: getUserTimeZone() });
  persistLog();
  // TODO: Update admin/projects list (e.g., save to a JSON file or DB)
  return { project: projectName, files: files.map(f => f.name), readme: readmePath };
}

// Helper to auto-generate docs and packaging for a project/package/extension
async function generateDocsAndPackaging(projectName: string, files: any[]) {
  const docs = `# ${projectName} Documentation\n\nAuto-generated docs for project: ${projectName}`;
  const readmePath = `/workspaces/Alpha-Q-ai/projects/${projectName}/README.md`;
  fs.writeFileSync(readmePath, docs);
  // Simulate packaging (e.g., zip/tar)
  // TODO: Implement real packaging logic
  return { docs: readmePath, packaging: null };
}

// --- Enhanced Creative Generators ---
async function enhancedGameGen(details: any) {
  // Add more thorough logic, error checking, and asset generation
  // ...
  return { status: 'success', details, assets: ['game.js', 'assets/', 'README.md'] };
}
async function enhancedAppDev(details: any) {
  // ...
  return { status: 'success', details, files: ['app.js', 'README.md'] };
}
async function enhancedMusicGen(details: any) {
  // ...
  return { status: 'success', details, files: ['track.wav', 'README.md'] };
}
async function enhancedArchitectureGen(details: any) {
  // ...
  return { status: 'success', details, files: ['model.obj', 'README.md'] };
}

// --- API Handler Enhancements ---
export const config = {
  api: {
    bodyParser: false,
  },
};

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // Simple admin auth
  const adminToken = req.headers['x-admin-token'];
  if (adminToken !== process.env.ADMIN_TOKEN) return res.status(403).json({ error: 'Forbidden' });
  loadLog();

  if (req.method === 'GET') {
    if (req.query.allStats) {
      // Return all AI tasks log
      return res.json({ tasks: aiTaskLog });
    }
    return res.status(400).json({ error: 'Unknown GET action' });
  }

  if (req.method === 'POST') {
    if (req.query.setTimeZone) {
      const { tz } = JSON.parse(req.body);
      setUserTimeZone(tz);
      return res.json({ status: 'ok', tz });
    }
    if (req.query.enhance) {
      // Trigger model enhancement
      const { desc } = JSON.parse(req.body);
      const task = await enhanceModel(desc);
      return res.json({ task });
    }
    if (req.query.upload) {
      // Handle file upload (using formidable for multipart)
      const formidable = require('formidable');
      const form = new formidable.IncomingForm();
      form.parse(req, async (err: any, fields: any, files: any) => {
        if (err) return res.status(500).json({ error: err.message });
        const file = files.file;
        if (!file) return res.status(400).json({ error: 'No file uploaded' });
        const fileData = {
          originalname: file.originalFilename,
          buffer: fs.readFileSync(file.filepath),
        };
        const task = await handleFileUpload(fileData);
        return res.json({ task });
      });
      return;
    }
    if (req.query.autoExtension) {
      const { projectType } = JSON.parse(req.body);
      const job = await autoDiscoverAndBuildExtension(projectType);
      return res.json({ job });
    }
    if (req.query.creativeFile) {
      const { type, details } = JSON.parse(req.body);
      const file = await creativeFileGen(type, details);
      return res.json({ file });
    }
    if (req.query.initiateProject) {
      const { projectName, files, userPrefs } = JSON.parse(req.body);
      const result = await createProject(projectName, files, userPrefs);
      await generateDocsAndPackaging(projectName, files);
      return res.json({ result });
    }
    if (req.query.enhancedGame) {
      const { details } = JSON.parse(req.body);
      const result = await enhancedGameGen(details);
      return res.json({ result });
    }
    if (req.query.enhancedApp) {
      const { details } = JSON.parse(req.body);
      const result = await enhancedAppDev(details);
      return res.json({ result });
    }
    if (req.query.enhancedMusic) {
      const { details } = JSON.parse(req.body);
      const result = await enhancedMusicGen(details);
      return res.json({ result });
    }
    if (req.query.enhancedArchitecture) {
      const { details } = JSON.parse(req.body);
      const result = await enhancedArchitectureGen(details);
      return res.json({ result });
    }
    return res.status(400).json({ error: 'Unknown POST action' });
  }
  return res.status(405).json({ error: 'Method not allowed' });
}
