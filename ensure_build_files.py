"""
ensure_build_files.py
Ensures that all required app binaries for all platforms and app types are present and valid (not placeholders),
and triggers automation to update README.md and RELEASESTRACKS.md in real time.
"""

import os
import sys
import hashlib

REQUIRED_APPS = [
    # (platform, extension, app_type)
    ("android", ".apk", "qmoi_ai"),
    ("windows", ".exe", "qmoi_ai"),
    ("mac", ".dmg", "qmoi_ai"),
    ("linux", ".AppImage", "qmoi_ai"),
    ("ios", ".ipa", "qmoi_ai"),
    ("chromebook", ".deb", "qmoi_ai"),
    ("raspberrypi", ".img", "qmoi_ai"),
    ("qcity", ".qcapp", "qmoi_ai"),
    ("smarttv", ".tvapp", "qmoi_ai"),
    # Add more as needed for QMOI Space, QCity, PWA, etc.
]

PLACEHOLDER_SIGNATURES = [
    b"QMOI QCity PWA qcapp",
    b"QMOI SmartTV app binary",
    b"placeholder",
    b"dummy",
    b"example",
    b"test",
    b"not meant for production",
]

def is_placeholder(filepath):
    try:
        with open(filepath, "rb") as f:
            content = f.read(256)
            for sig in PLACEHOLDER_SIGNATURES:
                if sig in content:
                    return True
            # Also treat files smaller than 10KB as likely placeholders
            if os.path.getsize(filepath) < 10 * 1024:
                return True
    except Exception:
        return True
    return False

def check_binaries():
    missing = []
    placeholders = []
    for platform, ext, app_type in REQUIRED_APPS:
        app_dir = os.path.join("scripts", "Qmoi_apps", platform)
        if not os.path.isdir(app_dir):
            missing.append((platform, app_type, "missing directory"))
            continue
        found = False
        for fname in os.listdir(app_dir):
            if fname.endswith(ext) and app_type.replace("_", " ") in fname.replace("_", " ").lower():
                fpath = os.path.join(app_dir, fname)
                found = True
                if is_placeholder(fpath):
                    placeholders.append((platform, app_type, fpath))
        if not found:
            missing.append((platform, app_type, "missing binary"))
    return missing, placeholders

def main():
    missing, placeholders = check_binaries()
    if missing or placeholders:
        print("\nERROR: The following issues were found with app binaries:")
        for m in missing:
            print(f"  MISSING: Platform={m[0]}, App={m[1]}, Reason={m[2]}")
        for p in placeholders:
            print(f"  PLACEHOLDER: Platform={p[0]}, App={p[1]}, File={p[2]}")
        print("\nPlease build and place the actual production binaries in the correct directories.")
        sys.exit(1)
    print("All required app binaries are present and valid.")
    # Trigger automation to update README.md and RELEASESTRACKS.md
    os.system("python3 scripts/auto_lint_fix.py --auto")
    os.system("python3 scripts/update_readme.py")
    os.system("python3 scripts/update_releases_tracks.py")

if __name__ == "__main__":
    main()
import os

# Required files with minimal content
def ensure_file(path, content=""):
    if not os.path.exists(path):
        with open(path, "w") as f:
            f.write(content)
            print(f"âœ… Created missing file: {path}")

# Public icon fallback
ensure_file("public/favicon.ico", "")


# Ensure installer.nsh exists (must contain real installer script, not a placeholder)
if not os.path.exists("installer/installer.nsh"):
    raise FileNotFoundError("installer/installer.nsh is missing. Please provide the real NSIS installer script.")

# License
ensure_file("installer/LICENSE.txt", "MIT License\n\nGenerated by QMOI AI")

# Icon fallback
if not os.path.exists("icon.ico"):
    os.system("python generate_icon.py")
