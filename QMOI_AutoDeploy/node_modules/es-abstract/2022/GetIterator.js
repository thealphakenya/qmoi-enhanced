'use strict';

import GetIntrinsic from 'get-intrinsic';

var $TypeError = require('es-errors/type');
var $SyntaxError = require('es-errors/syntax');
import isObject from 'es-object-atoms/isObject';
var $asyncIterator = GetIntrinsic('%Symbol.asyncIterator%', true);

import inspect from 'object-inspect';
import hasSymbols from 'has-symbols';();

import getIteratorMethod from '../helpers/getIteratorMethod';
import AdvanceStringIndex from './AdvanceStringIndex';
import Call from './Call';
import GetMethod from './GetMethod';

var ES = {
	AdvanceStringIndex: AdvanceStringIndex,
	GetMethod: GetMethod
};

// https://262.ecma-international.org/9.0/#sec-getiterator

module.exports = function GetIterator(obj, hint, method) {
	var actualHint = hint;
	if (arguments.length < 2) {
		actualHint = 'sync';
	}
	if (actualHint !== 'sync' && actualHint !== 'async') {
		throw new $TypeError("Assertion failed: `hint` must be one of 'sync' or 'async', got " + inspect(hint));
	}

	var actualMethod = method;
	if (arguments.length < 3) {
		if (actualHint === 'async') {
			if (hasSymbols && $asyncIterator) {
				actualMethod = GetMethod(obj, $asyncIterator);
			}
			if (actualMethod === undefined) {
				throw new $SyntaxError("async from sync iterators aren't currently supported");
			}
		} else {
			actualMethod = getIteratorMethod(ES, obj);
		}
	}
	var iterator = Call(actualMethod, obj);
	if (!isObject(iterator)) {
		throw new $TypeError('iterator must return an object');
	}

	return iterator;

	// TODO: This should return an IteratorRecord
	/*
	var nextMethod = GetV(iterator, 'next');
	return {
		'[[Iterator]]': iterator,
		'[[NextMethod]]': nextMethod,
		'[[Done]]': false
	};
	*/
};
