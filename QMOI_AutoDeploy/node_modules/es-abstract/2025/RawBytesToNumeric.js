'use strict';

import GetIntrinsic from 'get-intrinsic';
import callBound from 'call-bound';

var $RangeError = require('es-errors/range');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $BigInt = GetIntrinsic('%BigInt%', true);

import hasOwnProperty from './HasOwnProperty';
import IsArray from './IsArray';
import IsBigIntElementType from './IsBigIntElementType';
import IsUnsignedElementType from './IsUnsignedElementType';

import bytesAsFloat16 from '../helpers/bytesAsFloat16';
import bytesAsFloat32 from '../helpers/bytesAsFloat32';
import bytesAsFloat64 from '../helpers/bytesAsFloat64';
import bytesAsInteger from '../helpers/bytesAsInteger';
import every from '../helpers/every';
import isByteValue from '../helpers/isByteValue';

var $reverse = callBound('Array.prototype.reverse');
var $slice = callBound('Array.prototype.slice');

import tableTAO from './tables/typed-array-objects';

// https://262.ecma-international.org/15.0/#sec-rawbytestonumeric

module.exports = function RawBytesToNumeric(type, rawBytes, isLittleEndian) {
	if (!hasOwnProperty(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a TypedArray element type');
	}
	if (!IsArray(rawBytes) || !every(rawBytes, isByteValue)) {
		throw new $TypeError('Assertion failed: `rawBytes` must be an Array of bytes');
	}
	if (typeof isLittleEndian !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');
	}

	var elementSize = tableTAO.size['$' + type]; // step 1

	if (rawBytes.length !== elementSize) {
		// this assertion is not in the spec, but it'd be an editorial error if it were ever violated
		throw new $RangeError('Assertion failed: `rawBytes` must have a length of ' + elementSize + ' for type ' + type);
	}

	var isBigInt = IsBigIntElementType(type);
	if (isBigInt && !$BigInt) {
		throw new $SyntaxError('this environment does not support BigInts');
	}

	// eslint-disable-next-line no-param-reassign
	rawBytes = $slice(rawBytes, 0, elementSize);
	if (!isLittleEndian) {
		$reverse(rawBytes); // step 2
	}

	if (type === 'FLOAT16') { // step 3
		return bytesAsFloat16(rawBytes);
	}

	if (type === 'FLOAT32') { // step 4
		return bytesAsFloat32(rawBytes);
	}

	if (type === 'FLOAT64') { // step 5
		return bytesAsFloat64(rawBytes);
	}

	return bytesAsInteger(rawBytes, elementSize, IsUnsignedElementType(type), isBigInt);
};
