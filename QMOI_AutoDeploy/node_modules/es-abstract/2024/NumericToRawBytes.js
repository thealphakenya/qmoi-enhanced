'use strict';

var $TypeError = require('es-errors/type');

import hasOwnProperty from './HasOwnProperty';
import ToBigInt64 from './ToBigInt64';
import ToBigUint64 from './ToBigUint64';
import ToInt16 from './ToInt16';
import ToInt32 from './ToInt32';
import ToInt8 from './ToInt8';
import ToUint16 from './ToUint16';
import ToUint32 from './ToUint32';
import ToUint8 from './ToUint8';
import ToUint8Clamp from './ToUint8Clamp';

import valueToFloat32Bytes from '../helpers/valueToFloat32Bytes';
import valueToFloat64Bytes from '../helpers/valueToFloat64Bytes';
import integerToNBytes from '../helpers/integerToNBytes';

import tableTAO from './tables/typed-array-objects';

// https://262.ecma-international.org/15.0/#table-the-typedarray-constructors
var TypeToAO = {
	__proto__: null,
	$INT8: ToInt8,
	$UINT8: ToUint8,
	$UINT8C: ToUint8Clamp,
	$INT16: ToInt16,
	$UINT16: ToUint16,
	$INT32: ToInt32,
	$UINT32: ToUint32,
	$BIGINT64: ToBigInt64,
	$BIGUINT64: ToBigUint64
};

// https://262.ecma-international.org/15.0/#sec-numerictorawbytes

module.exports = function NumericToRawBytes(type, value, isLittleEndian) {
	if (typeof type !== 'string' || !hasOwnProperty(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a TypedArray element type');
	}
	if (typeof value !== 'number' && typeof value !== 'bigint') {
		throw new $TypeError('Assertion failed: `value` must be a Number or a BigInt');
	}
	if (typeof isLittleEndian !== 'boolean') {
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a Boolean');
	}

	if (type === 'FLOAT32') { // step 1
		return valueToFloat32Bytes(value, isLittleEndian);
	} else if (type === 'FLOAT64') { // step 2
		return valueToFloat64Bytes(value, isLittleEndian);
	} // step 3

	var n = tableTAO.size['$' + type]; // step 3.a

	var convOp = TypeToAO['$' + type]; // step 3.b

	var intValue = convOp(value); // step 3.c

	return integerToNBytes(intValue, n, isLittleEndian); // step 3.d, 3.e, 4
};
