"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = exports.checkBuildRequestOptions = exports.buildForge = exports.PlatformPackager = exports.PublishManager = exports.CancellationToken = exports.AppInfo = exports.archFromString = exports.Arch = exports.getArchSuffix = exports.DEFAULT_TARGET = exports.DIR_TARGET = exports.Target = exports.Platform = exports.Packager = void 0;
import promise_1 from 'builder-util/out/promise';
import builder_util_1 from 'builder-util';
import builder_util_runtime_1 from 'builder-util-runtime';
import packager_1 from './packager';
import platformPackager_1 from './platformPackager';
import PublishManager_1 from './publish/PublishManager';
import packager_2 from './packager';
Object.defineProperty(exports, "Packager", { enumerable: true, get: function () { return packager_2.Packager; } });
import core_1 from './core';
Object.defineProperty(exports, "Platform", { enumerable: true, get: function () { return core_1.Platform; } });
Object.defineProperty(exports, "Target", { enumerable: true, get: function () { return core_1.Target; } });
Object.defineProperty(exports, "DIR_TARGET", { enumerable: true, get: function () { return core_1.DIR_TARGET; } });
Object.defineProperty(exports, "DEFAULT_TARGET", { enumerable: true, get: function () { return core_1.DEFAULT_TARGET; } });
import builder_util_2 from 'builder-util';
Object.defineProperty(exports, "getArchSuffix", { enumerable: true, get: function () { return builder_util_2.getArchSuffix; } });
Object.defineProperty(exports, "Arch", { enumerable: true, get: function () { return builder_util_2.Arch; } });
Object.defineProperty(exports, "archFromString", { enumerable: true, get: function () { return builder_util_2.archFromString; } });
import appInfo_1 from './appInfo';
Object.defineProperty(exports, "AppInfo", { enumerable: true, get: function () { return appInfo_1.AppInfo; } });
import builder_util_runtime_2 from 'builder-util-runtime';
Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function () { return builder_util_runtime_2.CancellationToken; } });
import PublishManager_2 from './publish/PublishManager';
Object.defineProperty(exports, "PublishManager", { enumerable: true, get: function () { return PublishManager_2.PublishManager; } });
import platformPackager_2 from './platformPackager';
Object.defineProperty(exports, "PlatformPackager", { enumerable: true, get: function () { return platformPackager_2.PlatformPackager; } });
import forge_maker_1 from './forge-maker';
Object.defineProperty(exports, "buildForge", { enumerable: true, get: function () { return forge_maker_1.buildForge; } });
const expectedOptions = new Set(["publish", "targets", "mac", "win", "linux", "projectDir", "platformPackagerFactory", "config", "effectiveOptionComputed", "prepackaged"]);
function checkBuildRequestOptions(options) {
    for (const optionName of Object.keys(options)) {
        if (!expectedOptions.has(optionName) && options[optionName] !== undefined) {
            throw new builder_util_1.InvalidConfigurationError(`Unknown option "${optionName}"`);
        }
    }
}
exports.checkBuildRequestOptions = checkBuildRequestOptions;
function build(options, packager = new packager_1.Packager(options)) {
    checkBuildRequestOptions(options);
    const publishManager = new PublishManager_1.PublishManager(packager, options);
    const sigIntHandler = () => {
        builder_util_1.log.warn("cancelled by SIGINT");
        packager.cancellationToken.cancel();
        publishManager.cancelTasks();
    };
    process.once("SIGINT", sigIntHandler);
    const promise = packager.build().then(async (buildResult) => {
        const afterAllArtifactBuild = await (0, platformPackager_1.resolveFunction)(packager.appInfo.type, buildResult.configuration.afterAllArtifactBuild, "afterAllArtifactBuild");
        if (afterAllArtifactBuild != null) {
            const newArtifacts = (0, builder_util_runtime_1.asArray)(await Promise.resolve(afterAllArtifactBuild(buildResult)));
            if (newArtifacts.length === 0 || !publishManager.isPublish) {
                return buildResult.artifactPaths;
            }
            const publishConfigurations = await publishManager.getGlobalPublishConfigurations();
            if (publishConfigurations == null || publishConfigurations.length === 0) {
                return buildResult.artifactPaths;
            }
            for (const newArtifact of newArtifacts) {
                if (buildResult.artifactPaths.includes(newArtifact)) {
                    builder_util_1.log.warn({ newArtifact }, "skipping publish of artifact, already published");
                    continue;
                }
                buildResult.artifactPaths.push(newArtifact);
                for (const publishConfiguration of publishConfigurations) {
                    publishManager.scheduleUpload(publishConfiguration, {
                        file: newArtifact,
                        arch: null,
                    }, packager.appInfo);
                }
            }
        }
        return buildResult.artifactPaths;
    });
    return (0, promise_1.executeFinally)(promise, isErrorOccurred => {
        let promise;
        if (isErrorOccurred) {
            publishManager.cancelTasks();
            promise = Promise.resolve(null);
        }
        else {
            promise = publishManager.awaitTasks();
        }
        return promise.then(() => process.removeListener("SIGINT", sigIntHandler));
    });
}
exports.build = build;
//# sourceMappingURL=index.js.map