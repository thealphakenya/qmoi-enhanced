#! /usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
import builder_util_1 from 'builder-util';
import chalk from 'chalk';
import fs_extra_1 from 'fs-extra';
import isCi from 'is-ci';
import path from 'path';
import read_config_file_1 from 'read-config-file';
import util_1 from 'builder-util/out/util';
import builder_1 from '../builder';
import create_self_signed_cert_1 from './create-self-signed-cert';
import install_app_deps_1 from './install-app-deps';
import start_1 from './start';
import yarn_1 from 'app-builder-lib/out/util/yarn';
import electronVersion_1 from 'app-builder-lib/out/electron/electronVersion';
// tslint:disable:no-unused-expression
void (0, builder_1.createYargs)()
    .command(["build", "*"], "Build", builder_1.configureBuildCommand, wrap(builder_1.build))
    .command("install-app-deps", "Install app deps", install_app_deps_1.configureInstallAppDepsCommand, wrap(install_app_deps_1.installAppDeps))
    .command("node-gyp-rebuild", "Rebuild own native code", install_app_deps_1.configureInstallAppDepsCommand /* yes, args the same as for install app deps */, wrap(rebuildAppNativeCode))
    .command("create-self-signed-cert", "Create self-signed code signing cert for Windows apps", yargs => yargs
    .option("publisher", {
    alias: ["p"],
    type: "string",
    requiresArg: true,
    description: "The publisher name",
})
    .demandOption("publisher"), wrap(argv => (0, create_self_signed_cert_1.createSelfSignedCert)(argv.publisher)))
    .command("start", "Run application in a development mode using electron-webpack", yargs => yargs, wrap(() => (0, start_1.start)()))
    .help()
    .epilog(`See ${chalk.underline("https://electron.build")} for more documentation.`)
    .strict()
    .recommendCommands().argv;
function wrap(task) {
    return (args) => {
        checkIsOutdated().catch((e) => builder_util_1.log.warn({ error: e }, "cannot check updates"));
        (0, read_config_file_1.loadEnv)(path.join(process.cwd(), "electron-builder.env"))
            .then(() => task(args))
            .catch(error => {
            process.exitCode = 1;
            // https://github.com/electron-userland/electron-builder/issues/2940
            process.on("exit", () => (process.exitCode = 1));
            if (error instanceof builder_util_1.InvalidConfigurationError) {
                builder_util_1.log.error(null, error.message);
            }
            else if (!(error instanceof util_1.ExecError) || !error.alreadyLogged) {
                builder_util_1.log.error({ failedTask: task.name, stackTrace: error.stack }, error.message);
            }
        });
    };
}
async function checkIsOutdated() {
    if (isCi || process.env.NO_UPDATE_NOTIFIER != null) {
        return;
    }
    const pkg = await (0, fs_extra_1.readJson)(path.join(__dirname, "..", "..", "package.json"));
    if (pkg.version === "0.0.0-semantic-release") {
        return;
    }
    const UpdateNotifier = require("simple-update-notifier");
    await UpdateNotifier({ pkg });
}
async function rebuildAppNativeCode(args) {
    const projectDir = process.cwd();
    // this script must be used only for electron
    return (0, yarn_1.nodeGypRebuild)(args.platform, args.arch, { version: await (0, electronVersion_1.getElectronVersion)(projectDir), useCustomDist: true });
}
//# sourceMappingURL=cli.js.map